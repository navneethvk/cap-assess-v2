# Centralized Visit Query System

This document describes the new centralized query optimization system for visit/note data access in the application.

## Overview

The centralized query system provides:
- **Single source of truth** for all visit queries
- **Intelligent caching** with 5-minute cache duration
- **Query optimization** with built-in pagination and filtering
- **Type safety** with full TypeScript support
- **Performance improvements** through deduplication and smart caching

## Architecture

### Core Components

1. **`VisitQueryManager`** (`/services/VisitQueryManager.ts`)
   - Central service for all visit queries
   - Handles caching, query building, and optimization
   - Provides methods for different query patterns

2. **`useVisitQueries`** (`/hooks/useVisitQueries.ts`)
   - React hooks that wrap the query manager
   - Provides SWR-based caching and revalidation
   - Multiple specialized hooks for different use cases

3. **Backward Compatibility**
   - Old hooks (`useVisitsInRange`, `useUserVisits`) still work
   - They now delegate to the new centralized system
   - Gradual migration path for existing code

## Usage Examples

### Basic Date Range Query (NotesView)

```typescript
import { useVisitsInRange } from '@/hooks/useVisitQueries';

const NotesView = () => {
  const startDate = new Date('2024-01-01');
  const endDate = new Date('2024-01-31');
  
  const { visits, isLoading, error, refetch } = useVisitsInRange(startDate, endDate);
  
  // visits is now properly typed and cached
  return (
    <div>
      {visits.map(visit => (
        <div key={visit.id}>{visit.cci_name}</div>
      ))}
    </div>
  );
};
```

### User-Specific Visits

```typescript
import { useUserVisits } from '@/hooks/useVisitQueries';

const UserDashboard = () => {
  const { visits, isLoading } = useUserVisits({
    limit: 100,
    orderBy: 'date',
    orderDirection: 'desc'
  });
  
  return <div>{visits.length} visits found</div>;
};
```

### Advanced Filtering

```typescript
import { useVisitQueries } from '@/hooks/useVisitQueries';

const FilteredVisits = () => {
  const { visits } = useVisitQueries({
    startDate: new Date('2024-01-01'),
    endDate: new Date('2024-01-31'),
    status: 'Complete',
    cciId: 'specific-cci-id',
    limit: 50,
    orderBy: 'date',
    orderDirection: 'desc'
  });
  
  return <div>{visits.length} filtered visits</div>;
};
```

### Pagination

```typescript
import { usePaginatedVisits } from '@/hooks/useVisitQueries';

const PaginatedList = () => {
  const { 
    visits, 
    currentPage, 
    hasNextPage, 
    hasPrevPage, 
    nextPage, 
    prevPage 
  } = usePaginatedVisits({
    pageSize: 20,
    orderBy: 'date',
    orderDirection: 'desc'
  });
  
  return (
    <div>
      <button onClick={prevPage} disabled={!hasPrevPage}>Previous</button>
      <button onClick={nextPage} disabled={!hasNextPage}>Next</button>
      {visits.map(visit => <div key={visit.id}>{visit.cci_name}</div>)}
    </div>
  );
};
```

## Available Hooks

### Core Hooks

- **`useVisitQueries(options)`** - Main hook for custom queries
- **`useVisitsInRange(start, end, options)`** - Date range queries
- **`useUserVisits(options)`** - User-specific visits
- **`useVisitsForDate(date, options)`** - Single date queries
- **`useAllVisits(options)`** - All visits (admin only)

### Specialized Hooks

- **`useVisitsByCCI(cciId, options)`** - CCI-specific visits
- **`useVisitsByStatus(status, options)`** - Status-filtered visits
- **`usePaginatedVisits(options)`** - Paginated queries

### Utility Hooks

- **`usePreloadVisits()`** - Preload common queries
- **`useVisitCache()`** - Cache management

## Query Options

```typescript
interface VisitQueryOptions {
  // Date filtering
  startDate?: Date;
  endDate?: Date;
  
  // User filtering
  filledByUid?: string;
  
  // CCI filtering
  cciId?: string;
  
  // Status filtering
  status?: 'Complete' | 'Incomplete' | 'Pending' | 'Scheduled' | 'Cancelled';
  
  // Pagination
  limit?: number;
  startAfterDoc?: DocumentSnapshot;
  
  // Sorting
  orderBy?: 'date' | 'createdAt' | 'order';
  orderDirection?: 'asc' | 'desc';
  
  // Cache options
  cacheKey?: string;
  forceRefresh?: boolean;
  
  // SWR options
  revalidateOnFocus?: boolean;
  revalidateIfStale?: boolean;
  dedupingInterval?: number;
}
```

## Performance Benefits

### Caching
- **5-minute cache duration** for all queries
- **Intelligent cache keys** based on query parameters
- **Automatic cache invalidation** when data changes

### Query Optimization
- **Built-in pagination** with configurable limits
- **Efficient Firestore queries** with proper indexing
- **Deduplication** prevents duplicate requests

### Memory Management
- **LRU cache eviction** for large datasets
- **Configurable cache size** limits
- **Memory-efficient** data structures

## Migration Guide

### From Old Hooks

**Before:**
```typescript
import { useVisitsInRange } from '@/hooks/useVisitsInRange';

const { visits, isLoading, error } = useVisitsInRange(start, end);
```

**After:**
```typescript
import { useVisitsInRange } from '@/hooks/useVisitQueries';

const { visits, isLoading, error } = useVisitsInRange(start, end);
// Same API, better performance!
```

### From Direct Firestore Queries

**Before:**
```typescript
import { collection, query, where, getDocs } from 'firebase/firestore';

const fetchVisits = async () => {
  const q = query(
    collection(db, 'visits'),
    where('date', '>=', startDate),
    where('date', '<=', endDate)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

**After:**
```typescript
import { useVisitsInRange } from '@/hooks/useVisitQueries';

const { visits, isLoading, error } = useVisitsInRange(startDate, endDate);
// Automatic caching, error handling, and revalidation!
```

## Cache Management

### Manual Cache Control

```typescript
import { useVisitCache } from '@/hooks/useVisitQueries';

const CacheControls = () => {
  const { clearCache, getCacheStats } = useVisitCache();
  
  const handleClearCache = () => {
    clearCache(); // Clear all cache
    // or
    clearCache('visits|2024-01'); // Clear specific pattern
  };
  
  const handleShowStats = () => {
    const stats = getCacheStats();
    console.log('Cache size:', stats.size);
    console.log('Cache keys:', stats.keys);
  };
  
  return (
    <div>
      <button onClick={handleClearCache}>Clear Cache</button>
      <button onClick={handleShowStats}>Show Stats</button>
    </div>
  );
};
```

### Preloading

```typescript
import { usePreloadVisits } from '@/hooks/useVisitQueries';

const App = () => {
  const { preload } = usePreloadVisits();
  
  useEffect(() => {
    // Preload common queries on app start
    preload();
  }, []);
  
  return <div>App content</div>;
};
```

## Best Practices

### 1. Use Appropriate Hooks
- Use `useVisitsInRange` for date-based queries
- Use `useUserVisits` for user-specific data
- Use `useVisitQueries` for complex custom queries

### 2. Optimize Query Parameters
```typescript
// Good: Specific date range
const { visits } = useVisitsInRange(startDate, endDate);

// Better: Add limit for large datasets
const { visits } = useVisitsInRange(startDate, endDate, { limit: 100 });

// Best: Use appropriate sorting
const { visits } = useVisitsInRange(startDate, endDate, {
  limit: 100,
  orderBy: 'date',
  orderDirection: 'desc'
});
```

### 3. Handle Loading States
```typescript
const { visits, isLoading, error } = useVisitsInRange(start, end);

if (isLoading) return <div>Loading...</div>;
if (error) return <div>Error: {error.message}</div>;
return <div>{visits.length} visits found</div>;
```

### 4. Use Cache Effectively
```typescript
// Cache will be shared across components
const Component1 = () => {
  const { visits } = useVisitsInRange(start, end); // Fetches data
  return <div>{visits.length}</div>;
};

const Component2 = () => {
  const { visits } = useVisitsInRange(start, end); // Uses cache
  return <div>{visits.length}</div>;
};
```

## Troubleshooting

### Common Issues

1. **Cache not updating**
   - Use `forceRefresh: true` in options
   - Call `clearCache()` to reset cache
   - Check if query parameters changed

2. **Performance issues**
   - Add `limit` to large queries
   - Use specific date ranges
   - Consider pagination for large datasets

3. **Type errors**
   - Ensure proper TypeScript imports
   - Use the correct hook for your use case
   - Check query options types

### Debug Mode

```typescript
// Enable debug logging
const { visits } = useVisitsInRange(start, end, {
  cacheKey: 'debug-query', // Custom cache key for debugging
  forceRefresh: true // Force fresh data
});
```

## Future Enhancements

- **Real-time updates** with Firestore listeners
- **Offline support** with local storage caching
- **Query analytics** and performance monitoring
- **Advanced filtering** with complex conditions
- **Bulk operations** for multiple queries

## Support

For questions or issues with the centralized query system:
1. Check this documentation
2. Review the example components in `/examples/`
3. Check the TypeScript types for proper usage
4. Test with the development server for debugging


